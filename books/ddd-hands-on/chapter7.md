---
title: '第2部 戦術的設計 (コード実装)'
---

# 1 部のまとめと 2 部で何するか入れる

# 戦術的設計とは

戦術的設計とは、ビジネスの複雑性をコードにどのように反映させるか、具体的なアプローチやパターンに焦点を当てたものです。第 1 部で行ったドメインモデリングでの成果物を DDD のアプローチやパターン (値オブジェクト、エンティティ、集約、リポジトリなど) を紹介すると共に実際にコードに反映していきます。

# アーキテクチャ

ドメイン駆動設計には固有のアーキテクチャはありません。アーキテクチャとは、ソフトウェアアプリケーションを構築する際の設計思想と構造計画であり、ドメイン駆動設計のアプローチやパターンをどのように実装するかを決めるものです。良いアーキテクチャは、要件の変更や新しい技術の採用に柔軟に対応し、システムのパフォーマンス、スケーラビリティ、セキュリティを最適化する手助けとなります。

アーキテクチャにはレイヤードアーキテクチャ、オニオンアーキテクチャ、ヘキサゴナルアーキテクチャ、クリーンアーキテクチャなどさまざまな種類ががあります。この本ではドメイン駆動設計のアーキテクチャに**オニオンアーキテクチャ**を採用しています。

## オニオンアーキテクチャとは

オニオンアーキテクチャは、ソフトウェアの設計パターンの一つで、アプリケーションを複数のレイヤーで構成し、それらを円形に配置することを特徴とします。このアーキテクチャは、ドメイン駆動設計との相性も良いです。

## オニオンアーキテクチャの特徴

オニオンアーキテクチャは一般的に以下のような図で表現されます。
![](https://storage.googleapis.com/zenn-user-upload/ea8459dbb430-20231121.png)

この図を参考にオニオンアーキテクチャの特徴を見ていきましょう。

### ドメイン中心の設計

オニオンアーキテクチャは、アプリケーションの中心にドメインモデル（ビジネスロジック）を置き、他の層はこのドメインモデルを取り囲む形で構築されます。**ドメイン層が他の層に依存しない**ようにすることで、ドメインモデルを独立して開発することができます。

### レイヤー構造

オニオンアーキテクチャでは、アプリケーションを複数のレイヤーに分割します。ドメイン駆動設計において各レイヤーにはそれぞれ以下のような役割があります。

| レイヤー                   | 説明                                                                                                                                                                                   |
| -------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **ドメイン層**             | これはアプリケーションのコアであり、ビジネスルールやビジネスロジックを表現します。主にエンティティ、値オブジェクト、ドメインサービス、およびリポジトリのインターフェイスが含まれます。 |
| **アプリケーション層**     | アプリケーション層はドメイン層のクライアントです。ユースケースを組み立てるためにドメイン層を使用します。主にアプリケーションサービスが含まれます。                                     |
| **インフラストラクチャ層** | この層はアプリケーションに必要な外部リソース (データベース、ファイルシステム、外部サービスへの通信など) を担当します。主にリポジトリの実装が含まれます。                               |
| **プレゼンテーション層**   | ユーザーのリクエストを受け取り、適切な応答を返します。主に Web UI、REST API、CLI などが含まれます。                                                                                    |

### 依存関係の向き

オニオンアーキテクチャでは、依存関係に明確な方向性があります。このアーキテクチャは、外側のレイヤー（アプリケーション層やインフラ層）から内側のレイヤー（ドメイン層）への一方向の依存関係を強制します。このようにすることで、以下のような問題点を解決または軽減します。

- **ドメイン層の独立性**
  ドメイン層はアプリケーションのビジネスロジックの中心であり、他の層に依存しないようにすることが重要です。これにより、ビジネスロジックが他の層の変更に影響を受けることがなくなり、ドメインモデルを独立して開発することができます。

- **テストの容易性**
  ドメイン層が他の層に依存しないため、単体テストが容易になります。ビジネスロジックを他のレイヤーから分離することで、モックやスタブを使用せずにテストが行え、テストの容易性が向上します。

- **拡張性と保守性の向上**
  各層が特定の責任を持ち、依存関係を制御することで、システムの変更が容易になります。たとえば、インフラストラクチャ層の変更がドメイン層に影響を及ぼすことはありません。これにより、新しい機能の追加や既存機能の変更がより容易になります。

- **再利用性の向上**
  ドメイン層が独立しているため、ビジネスロジックを別のアプリケーションやプロジェクトで再利用することが容易になります。これは、ドメイン層がアプリケーションやインフラストラクチャの特定の実装に依存しないことによるものです。

:::message
オニオンアーキテクチャを利用してレイヤーを分離し、依存関係を制御する事によるメリットは説明だけではわかりにくいため、第 2 部で実際にコードを書きながら理解していきましょう。
:::

# 環境のセットアップ

次の章に進む前に、TypeScript の環境をセットアップしましょう。
node のバージョンは 「18.15.0」 です。

```bash
$ node -v
v18.15.0
```

### npm プロジェクトの初期化

```bash:StockManagement/
$ npm init -y
```

### src ディレクトリの作成

src ディレクトリを作成し Domain ディレクトリを移動します。

```bash:StockManagement/
$ mkdir src && mv Domain/ src/
```

### パッケージのインストール

必要なパッケージをインストールしていきます。

```bash:StockManagement/
$ npm i -D typescript ts-node tsconfig-paths @types/node jest ts-jest @types/jest
```

### TypeScript の設定

tsconfig.json を作成し以下のコードをコピーします。オプションはお好みで追加してください。

```json:StockManagement/tsconfig.json
{
  "ts-node": {
    "require": ["tsconfig-paths/register"]
    // ts-nodeがtsconfigのpathsを解決できるようにします。
  },
  "compilerOptions": {
    "outDir": "./dist",
    "strict": true,
    "resolveJsonModule": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "baseUrl": "./",
    "paths": {
      "*": ["./src/*"]
    },
    "esModuleInterop": true
  },
  "include": ["src/**/*.ts", "src/**/*.js"],
  "exclude": ["node_modules"]
}

```

### TypeScript の動作確認

「sayHello.ts」 を作成し以下のコードをコピーします。

```js:StockManagement/src/sayHello.ts
export const sayHello = (name: string): void => {
  console.log(`Hello ${name}!`);
};

sayHello('World');

```

```bash:StockManagement/
$ ts-node src/sayHello.ts
```

ts-node で実行しターミナルに「Hello World!」が表示されば OK です。

### Jest の設定

「jest.config.js」 を作成し以下のコードをコピーします。

```js:StockManagement/jest.config.js
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  moduleDirectories: ['node_modules', 'src'],
  transformIgnorePatterns: ['/node_modules'],
};
```

### Jest の動作確認

テストには jest を利用します。
「sayHello.test.ts」 を作成し以下のコードをコピーします。

```js:StockManagement/src/sayHello.test.ts
import { sayHello } from './sayHello';

test('sayHello', () => {
  expect(sayHello('World')).toBe('Hello World');
});

```

```bash:StockManagement/
$ jest src/sayHello.test.ts
```

テストに成功すれば OK です。
「sayHello.ts」と「sayHello.test.ts」は以降使用しないため削除しましょう。

# まとめ

以上で環境のセットアップは完了です。それでは次章から戦術的設計のアプローチを確認しながらコードの実装を行なっていきましょう行なっていきましょう。

### これまでのコード

https://github.com/yamachan0625/ddd-hands-on/tree/setup
